/*
 * Parsing.
 *
 * Copyright (c) 2014 Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file Parsing summary and report files.
 *
 * There are two kinds of summaries in fateserver: the old-style
 * colon-seperated summary files, and the newer JSON summary.json files.
 * They are both handled by
 * {@link module:./lib/parse.loadSummary|loadSummary()}.
 *
 * Older summary files has three lines: one with header, one with config, one
 * with stats. They were generated by fate-recv.sh. The first two lines were
 * copied straight from uploaded report file. The contents of the third line
 * was calculated by iterating over all tests in report file.
 *
 * In Node.js version of fateserver, fate-recv.sh no longer generates a
 * summary file, but a summary.json file with generateSummary.js. It basically
 * does the same thing, but the number of warnings is passed into the script
 * from fate-recv.sh (at this moment).
 *
 * Some split* functions are marked as private in JSDoc because they are only
 * used in generateSummary.js and only operate on deprecated summary files.
 *
 * @module ./lib/parse
 */

var fs = require('fs')
var readline = require('readline')
var path = require('path')

var fate_config = require('./config')

/**
 * Turns arrays of keys and values to an object.
 *
 * @param {array} keys   Array of keys
 * @param {array} values Array of values that correspond with the keys.
 * @return The resulting object
 *
 * @private
 */
function toObject(keys, values) {
    var obj = {}
    for (var i = 0; i < keys.length; i++) {
        if (!values[i] && values[i] !== '') {
            require('debug')('toObject')('Index ' + i + ' invalid')
            return null
        }
        obj[keys[i]] = values[i]
    }
    return obj
}

/**
 * Split a line into an object with objKeys, with delimiter ':'.
 *
 * If numbers is specified, the properties in the output object with the name
 * one of the member of the the numbers array will be coerced into Number
 * type.
 *
 * @param {string} line     Line to be splitted
 * @param {array}  objKeys  Keys of the line
 * @param {array} [numbers] Names of properties that are numbers
 *
 * @return the resulting object
 *
 * @private
 */

function splitLine(line, objKeys, numbers) {
    var outObj = toObject(objKeys, line.split(':'))
    if (!outObj)
        return null
    if (arguments.length === 3) {
        for (var i = 0; i < numbers.length; i++) {
            var prop = numbers[i]
            if (outObj.hasOwnProperty(prop))
                outObj[prop] = Number(outObj[prop])
            // XXX: Should we set the property to 0 as a fallback?
        }
    }
    return outObj
}

/**
 * Parses a `header` line in a report file or old-style summary file.
 *
 * @param {string} line     Line to be splitted
 * @return The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitHeader = function(line) {
    var objKeys = ['header', 'version', 'date', 'slot', 'rev', 'status',
                   'errstr', 'comment']
    return splitLine(line, objKeys, ['date', 'status'])
}
var splitHeader = module.exports.splitHeader

/**
 * Parses a `config` line in a report file or old-style summary file.
 *
 * @param {string} line     Line to be splitted
 * @return The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitConfig = function(line) {
    var objKeys = ['header', 'arch', 'subarch', 'cpu', 'os', 'cc', 'config']
    return splitLine(line, objKeys)
}
var splitConfig = module.exports.splitConfig

/**
 * Parses a `stats` line in a old-style summary file.
 *
 * @param {string} line     Line to be splitted
 * @return The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitStats = function(line) {
    var objKeys = ['header', 'ntests', 'npass', 'nwarn']
    var outObj  = splitLine(line, objKeys, ['ntests', 'npass', 'nwarn'])

    return outObj
}
var splitStats = module.exports.splitStats

/**
 * @typedef Rec
 *
 * @prop {string} name   Name of the test.
 * @prop {string} status Return code of the test command.
 * @prop {string} diff   Base64-encoded diff.
 * @prop {string} stderr Base64-encoded stderr output.
 */

/**
 * Parses a record line in a report file.
 *
 * @param {string} line     Line to be splitted
 * @return The resulting {@link Rec} object, or null if an error occurred.
 */
module.exports.splitRec = function(line) {
    var objKeys = ['name', 'status', 'diff', 'stderr']
    return splitLine(line, objKeys, ['status'])
}
splitRec = module.exports.splitRec

/**
 * Summaries are the metadata associated with a FATE run. This function
 * creates a Summary object with header, config, and stats merged into a
 * single object.
 *
 * @param {header} h Header object as returned by splitHeader()
 * @param {config} c Configuration object as returned by splitConfig()
 * @param {stats}  s Stats object as returned by splitStats() or created from
 *                   the report file.
 *
 * @prop {number} version The version of the report file.
 * @prop {number} date    The timestamp.
 * @prop {string} slot    The slot.
 * @prop {string} rev     Revision of the source.
 * @prop {number} status  Final status of the building process.
 * @prop {string} errstr  Error description, if there is an error.
 * @prop {string} comment Any additional comments from the slot owner.
 *
 * @prop {string} arch    The architecture.
 * @prop {string} subarch The variant of the architecture.
 * @prop {string} cpu     The selected CPU.
 * @prop {string} os      The operating system.
 * @prop {string} cc      The compiler.
 * @prop {string} config  The build-time configure flags.
 *
 * @prop {number} ntests  Number of tests run.
 * @prop {number} npass   Number of tests passed.
 * @prop {number} nfail   Number of failed tests
 * @prop {number} nwarn   Number of compiler warnings.
 *
 * @prop {string} rclass  HTML class of the run
 * @prop {string} rtext   HTML text of the run
 *
 * @constructor
 */
module.exports.Summary = function(h, c, s) {
    var prop
    for (prop in h) {
        if (prop !== 'header')
            if (h.hasOwnProperty(prop))
                this[prop] = h[prop]
    }
    for (prop in c) {
        if (prop !== 'header')
            if (c.hasOwnProperty(prop))
                this[prop] = c[prop]
    }
    for (prop in s) {
        if (prop !== 'header')
            if (s.hasOwnProperty(prop))
                this[prop] = s[prop]
    }

    this.nfail = this.ntests - this.npass
    if (this.npass) {
        this.rclass = this.nfail ? 'warn' : 'pass'
        this.rtext  = this.npass + ' / ' + this.ntests
    } else if (!this.ntests && !this.status) {
        this.rclass = 'pass'
        this.rtext  = 'build only'
    } else {
        this.rclass = 'fail'
        this.rtext  = this.errstr
    }
}
Summary = module.exports.Summary

/**
 * Load an old style summary file.
 *
 * Please always call loadSummary() instead of calling this directly.
 *
 * @param slot     {string}         The slot.
 * @param date     {number}         The timestamp.
 * @param callback {function (err, Summary)} Callback receiving the Summary object.
 * @private
 */
function loadSummaryFile(slot, date, callback) {
    var header = null, config = null, stats = null
    var repdir = path.join(fate_config.dir, slot, date)

    fs.exists(path.join(repdir, 'summary'), function(exists) {
        if (exists) {
            var summary = fs.createReadStream(path.join(repdir, 'summary'))
            var err = null

            var lr = new readline.createInterface({
                input: summary,
                terminal: false
            })

            lr.on('line', function(line) {
                function checkLine(obj, name) {
                    if (!obj) {
                        var msg = "Could not parse " + name + " correctly:\n" 
                                  + line
                        if (err) {
                            err.msg += '\n'
                            err.msg += msg
                            // Don't append stack trace as the stack trace
                            // is always going to be the same
                        } else {
                            err = new Error(msg)
                            err.status = 500
                        }
                    }
                }
                switch (line.split(':')[0]) {
                case 'fate':
                    if (!header) {
                        header = splitHeader(line)
                        checkLine(header, 'header')
                    }
                    break
                case 'config':
                    if (!config) {
                        config = splitConfig(line)
                        checkLine(config, 'config')
                    }
                    break
                case 'stats':
                    if (!stats) {
                        stats = splitStats(line)
                        checkLine(stats, 'stats')
                    }
                    break
                // FIXME: should we error out on unrecognized lines too?
                }
            }).on('close', function() {
                callback(err, new Summary(header, config, stats))
            })
        } else {
            var err = new Error('Slot "' + slot + '"does not exist.')
            err.status = 404
            callback(err)
        }
    })
}

/**
 * Load the summary of an entry.
 *
 * This automatically manages whether to read old-style summary file or
 * new summary.json file.
 *
 * @param slot     {string}         The slot.
 * @param date     {number}         The timestamp.
 * @param callback {function (rep)} Callback receiving the Summary object.
 */
module.exports.loadSummary = function(slot, date, callback) {
    var repdir = path.join(fate_config.dir, slot, date)
    fs.exists(path.join(repdir, 'summary.json'), function(exists) {
        if (exists) {
            callback(null, require(path.join(repdir, 'summary.json')))
        } else {
            loadSummaryFile(slot, date, callback)
        }
    })
}
loadSummary = module.exports.loadSummary

module.exports.getSlotOwner = function(slot) {
    var data = null

    try {
        data = fs.readFileSync(path.join(fate_config.dir, slot, 'owner'),
                               'utf8')
    } catch (err) {
        err.message = 'Slot "' + slot + '" does not exist.'
        err.status  = 404
        throw err
    }

    return data
}
getSlotOwner = module.exports.getSlotOwner
