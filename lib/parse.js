/*
 * Parsing.
 *
 * Copyright (c) 2014 Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file Parsing summary and report files.
 *
 * Summary files has three lines: one with header, one with config, one
 * with stats. They were generated by fate-recv.sh. The first two lines were
 * copied straight from uploaded report file. The contents of the third line
 * was calculated by iterating over all tests in report file.
 *
 * @module lib/parse
 */

'use strict'

var fs = require('fs')
  , readline = require('readline')
  , path = require('path')
  , xz = require('xz-pipe')
  , debug = require('debug')('f:l:parse')

var util       = require('./util')
  , sort       = require('./sort')
  , cache      = require('./cache')
  , cacheLock  = require('./cache').lock

/**
 * Parses a `header` line in a report file or old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
function splitHeader (line) {
  var s = line.split(':')
    , header = { version: +s[1], date   : +s[2]
               , slot   :  s[3], rev    :  s[4]
               , status : +s[5], errstr :  s[6]
               , branch :  s[7], comment:  s[8]
               }
  if (header.version === 0) {
    header.branch = 'master'
    header.comment = s[7]
  }
  return header
}

/**
 * Parses a `config` line in a report file or old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
function splitConfig (line) {
  var c = line.split(':')
  return { arch: c[1], subarch: c[2]
         , cpu : c[3], os     : c[4]
         , cc  : c[5], config : c[6]
         }
}

/**
 * Parses a `stats` line in a old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
function splitStats (line) {
  var s = line.split(':')
  return { ntests: +s[1]
         , npass : +s[2]
         , nwarn : +s[3]
         }
}

/**
 * This type of object is used for a single test record.
 *
 * @typedef Record
 *
 * @prop {string} name   Name of the test.
 * @prop {string} status Return code of the test.
 * @prop {(string|undefined)} diff   Base64-encoded diff.
 * @prop {(string|undefined)} stderr Base64-encoded stderr output.
 */

/**
 * Parses a record line in a report file.
 *
 * @param  {string} line Line to be splitted
 * @param  {number} errdiff Verbosity of the record. 0 - no stderr or diff.
 *                          1 - stderr and diff only if the status is < 0.
 *                          2 - always include stderr and diff
 * @return {?Record} The resulting {@link Record} object, or null if an error
 *                  occurred.
 */
// TODO add errdiff doc to all the other places too
function splitRec (line, errdiff) {
  errdiff = errdiff === undefined ? 1 : errdiff
  var r = line.split(':')
  switch (errdiff) {
    case 0: return { name: r[0], status: +r[1] }
    case 1: return +r[1] === 0
                 ? { name: r[0], status:  0    }
                 : { name: r[0], status: +r[1], diff: r[2], stderr: r[3] }
    case 2: return { name: r[0], status: +r[1], diff: r[2], stderr: r[3] }
  }
}

/**
 * Summaries are the metadata associated with a FATE run. This function
 * creates a Summary object with header, config, and stats merged into a
 * single object.
 *
 * @param {header} h Header object as returned by splitHeader()
 * @param {config} c Configuration object as returned by splitConfig()
 * @param {stats}  s Stats object as returned by splitStats() or created from
 *                   the report file.
 *
 * @prop {number} version The version of the report file.
 * @prop {Timestamp} date The timestamp.
 * @prop {string} slot    The slot.
 * @prop {string} rev     Revision of the source.
 * @prop {number} status  Final status of the building process.
 * @prop {string} errstr  Error description, if there is an error.
 * @prop {string} comment Any additional comments from the slot owner.
 *
 * @prop {string} arch    The architecture.
 * @prop {string} subarch The variant of the architecture.
 * @prop {string} cpu     The selected CPU.
 * @prop {string} os      The operating system.
 * @prop {string} cc      The compiler.
 * @prop {string} config  The build-time configure flags.
 *
 * @prop {number} ntests  Number of tests run.
 * @prop {number} npass   Number of tests passed.
 * @prop {number} nfail   Number of failed tests
 * @prop {number} nwarn   Number of compiler warnings.
 *
 * @prop {string} rclass  HTML class of the run
 * @prop {string} rtext   HTML text of the run
 *
 * @constructor
 */
module.exports.Summary = function (h, c, s) {
  var prop
  for (prop in h) {
    if (h.hasOwnProperty(prop)) this[prop] = h[prop]
  }
  for (prop in c) {
    if (c.hasOwnProperty(prop)) this[prop] = c[prop]
  }
  for (prop in s) {
    if (s.hasOwnProperty(prop)) this[prop] = s[prop]
  }

  // Postprocessing
  // Calculate nfail property
  this.nfail = this.ntests - this.npass

  // Calculate rclass and rtext for HTML display
  if (this.npass) {
    this.rclass = this.status ? 'warn' : 'pass'
    this.rtext  = this.npass + ' / ' + this.ntests
  } else if (!this.ntests && !this.status) {
    this.rclass = 'pass'
    this.rtext  = 'build only'
  } else {
    this.rclass = 'fail'
    this.rtext  = this.errstr
  }

  // Always make subarch non-empty
  if (!this.subarch) this.subarch = this.arch
}
var Summary = module.exports.Summary

/**
 * This type of callback is used for {@link loadSummary}() that returns an
 * {@link Summary} object.
 *
 * @callback summaryCallback
 * @param {Error}   err The error occurred in the function if any.
 * @param {Summary} rep The resulting {@link Summary} object. (rep = report)
 */

/**
 * Load a summary file.
 *
 * @param slot     {string}         The slot.
 * @param date     {Timestamp}      The timestamp.
 * @param callback {summaryCallback} Callback receiving the Summary object.
 * @private
 */
function loadSummary (slot, date, callback) {
  var header = null, config = null, stats = null
  var repdir = path.join(util.dir, slot, date)

  var summary = fs.createReadStream(
    path.join(repdir, 'summary')
  ).on('error', function (err) {
    err.HTMLMessage = 'Slot "' + slot + '" does not exist.'
    err.status = 404
    return callback(err)
  })

  var err = null

  var lr = new readline.createInterface({
    input: summary
  , terminal: false
  })

  lr.on('line', function handleLine (line) {
    function checkLine (obj, name) {
      if (!obj) {
        var msg = "Could not parse " + name + " correctly:\n" + line
        if (err) {
          err.message += '\n'
          err.message += msg
          // Don't append stack trace as the stack trace
          // is always going to be the same
        } else {
          err = new Error(msg)
          err.status = 500
        }
      }
    }
    switch (line.split(':')[0]) {
    case 'fate':
      if (!header) {
        header = splitHeader(line)
        checkLine(header, 'header')
      }
      break
    case 'config':
      if (!config) {
        config = splitConfig(line)
        checkLine(config, 'config')
      }
      break
    case 'stats':
      if (!stats) {
        stats = splitStats(line)
        checkLine(stats, 'stats')
      }
      break
    }
  }).on('close', function close () {
    callback(err, new Summary(header, config, stats))
  })
}
module.exports.loadSummary = loadSummary

/**
 * This type of callback is used for functions that return an array of
 * {@link Record} object(s).
 *
 * @callback recCallback
 *
 * @param {?Error}          err   The error occurred in the function, if any.
 *                                Beware that sometimes even if there is an
 *                                error this argument might be `null`.
 * @param {?Array.<Record>} recs  The resulting array of {@link Record} object
 *                                or `null` if there is any error.
 */

/**
 * Load the test report of an entry. It loads the xz-compressed report.xz and
 * splits it into {@link Record}s, then calls the callback with the completed
 * data.
 *
 * @param slot     {string}          The slot.
 * @param date     {number}          The timestamp.
 * @param callback {recCallback}     Callback receiving the array of
 *                                   {@link Record} objects.
 */
module.exports.loadReport = function loadReport (slot, date, errdiff, cb) {
  var repFile = path.join(slot, date, 'report.xz')
    , repPath = path.join(util.dir, repFile)
    , cacheName = ['report', slot, date, errdiff].join('_')
    , cacheHasIt = false

  cacheLock.readLock(function (r) {
    if (cache.has(cacheName)) {
      debug('cache hit')
      var data = cache.get(cacheName)
      cacheHasIt = true
      cb(null, data)
    }
    r()
  })
  if (cacheHasIt) return
  debug('cache miss')

  var fileStream = fs.createReadStream(repPath)
                     .on('error', function noReport (err) {
    err.status = 404
    err.HTMLMessage = 'Report "' + repFile + '" not found.'
    return cb(err)
  })

  // Have to use an empty error handler to prevent uncaught exception in
  // .pipe().
  // Don't explicitly handle errors as it is hard to avoid race conditions
  // and the stream's close event might be emitted before error signal
  // here.
  var stream = fileStream.pipe(xz.d().on('error', function () {}))
  var recs = []
  var lr = new readline.createInterface({
    input: stream
  , terminal: false
  })

  lr.on('line', function handleLine (line) {
    var rec = splitRec(line, errdiff)
    // Don't care to check if the line is indeed a test record.
    // Depend on splitRec()'s judgment.
    if (rec && rec.name != 'fate' && rec.name != 'config') {
      recs[recs.length] = rec
    }
  }).on('close', function close () {
    var data = recs.sort(sort.by('name'))
    cacheLock.writeLock(function (r) {
      cache.set(cacheName, data)
      r()
    })
    cb(null, data)
  })
}

/**
 * Get the slot owner name.
 * The owner of a slot is stored in <fatedir>/<slot>/owner.
 *
 * @param slot {string} The slot.
 * @return     {string} The owner of the slot.
 */
module.exports.getSlotOwner = function (slot, callback) {
  fs.readFile(path.join(util.dir, slot, 'owner') , 'utf8', function (e, d) {
    // ignore error
    // at worst the page will display "owner: null" anyway
    // no need to handle it
    callback(null, d.trim())
  })
}

module.exports.loadLastPass = function (slot, callback) {
  var debug = require('debug')('f:parse:loadLastPass')

  var repdir = path.join(util.dir, slot)

  var lastPass = fs.createReadStream(
    path.join(repdir, 'lastpass')
  ).on('error', function noSlotLastpass (err) {
    err.HTMLMessage = 'Slot "' + slot + '" does not exist.'
    err.status = 404
    return callback(err)
  })

  var recs = []

  var lr = new readline.createInterface({
    input: lastPass
  , terminal: false
  })
  lr.on('line', function handleLine (line) {
    var splittedLine = line.split(':')
    if (splittedLine.length !== 3) return
    recs[splittedLine[0]] = {
      date: Number(splittedLine[1])
    , rev:  splittedLine[2]
    }
  }).on('close', function close () {
    callback(null, recs)
  })
}
