/*
 * Parsing.
 *
 * Copyright (c) 2014 Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @file Parsing summary and report files.
 *
 * Summary files has three lines: one with header, one with config, one
 * with stats. They were generated by fate-recv.sh. The first two lines were
 * copied straight from uploaded report file. The contents of the third line
 * was calculated by iterating over all tests in report file.
 *
 * @todo fix the visibility of split* functions
 * @module lib/parse
 */

'use strict'

var fs = require('fs')
  , readline = require('readline')
  , path = require('path')
  , xz = require('xz-pipe')

var fateConfig = require('./config')
  , sort       = require('./sort')

/**
 * Turns arrays of keys and values to an object.
 *
 * @param {Array.<string>} keys   Array of keys
 * @param {Array.<string>} values Array of values that correspond with the keys.
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
function toObject (keys, values, firstPropName) {
  var obj = {}

  for (var i = 0; i < keys.length; i++) {
    if (!values[i] && values[i] !== '') {
      require('debug')('toObject')('Index ' + i + ' invalid')
      return null
    }
    obj[keys[i]] = values[i]
  }
  return obj
}

/**
 * Split a line into an object with objKeys, with delimiter `:`.
 *
 * If numbers is specified, the properties in the output object with the name
 * one of the member of the the numbers array will be coerced into Number
 * type.
 *
 * @param {string}          line     Line to be splitted
 * @param {Array.<string>}  objKeys  Keys of the line
 * @param {Array.<string>} [numbers] Names of properties that are numbers
 *
 * @return {object|null} The resulting object, or null if there is an error.
 *
 * @private
 */

function splitLine (line, objKeys, numbers) {
  numbers = numbers || []
  var outObj = toObject(objKeys, line.split(':'))
  if (!outObj)
    return null
  if (arguments.length === 3) {
    for (var i = 0; i < numbers.length; i++) {
      var prop = numbers[i]
      if (outObj.hasOwnProperty(prop)) {
        outObj[prop] = Number(outObj[prop])
      }
      // XXX: Should we set the property to 0 as a fallback?
    }
  }
  return outObj
}

/**
 * Parses a `header` line in a report file or old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitHeader = function (line) {
  var objKeys = [
    'header', 'version', 'date', 'slot', 'rev', 'status'
    , 'errstr', 'comment'
  ]
  var header = splitLine(line, objKeys, ['version', 'date', 'status'])
  if (!header) {
    return null
  } else if (header.version === 1) {
    var objKeys = [
      'header', 'version', 'date', 'slot', 'rev', 'status'
    , 'errstr', 'branch', 'comment'
    ]
    header = splitLine(line, objKeys, ['version', 'date', 'status'])
  } else {
    header.branch = 'master'
  }
  return header
}
var splitHeader = module.exports.splitHeader

/**
 * Parses a `config` line in a report file or old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitConfig = function (line) {
  var objKeys = ['header', 'arch', 'subarch', 'cpu', 'os', 'cc', 'config']
  return splitLine(line, objKeys)
}
var splitConfig = module.exports.splitConfig

/**
 * Parses a `stats` line in a old-style summary file.
 *
 * @param  {string} line Line to be splitted
 * @return {object|null} The resulting object, or null if an error occurred.
 *
 * @private
 */
module.exports.splitStats = function (line) {
  var objKeys = ['header', 'ntests', 'npass', 'nwarn']
  var outObj  = splitLine(line, objKeys, ['ntests', 'npass', 'nwarn'])

  return outObj
}
var splitStats = module.exports.splitStats

/**
 * This type of object is used for a single test record.
 *
 * @typedef Record
 *
 * @prop {string} name   Name of the test.
 * @prop {string} status Return code of the test command.
 * @prop {string} diff   Base64-encoded diff.
 * @prop {string} stderr Base64-encoded stderr output.
 */

/**
 * Parses a record line in a report file.
 *
 * @param  {string} line Line to be splitted
 * @return {Record|null} The resulting {@link Record} object, or null if an error
 *                  occurred.
 */
module.exports.splitRec = function (line, errdiff) {
  var objKeys = ['name', 'status']
  if (errdiff > 0) {
    objKeys.push('diff', 'stderr')
  }
  var obj = splitLine(line, objKeys, ['status'])
  // Remove all stderr and diff from the obj
  if (errdiff === 1 && !obj.obj.status) {
    delete obj.obj.diff
    delete obj.obj.stderr
  }
  return obj
}
var splitRec = module.exports.splitRec

/**
 * Summaries are the metadata associated with a FATE run. This function
 * creates a Summary object with header, config, and stats merged into a
 * single object.
 *
 * @param {header} h Header object as returned by splitHeader()
 * @param {config} c Configuration object as returned by splitConfig()
 * @param {stats}  s Stats object as returned by splitStats() or created from
 *                   the report file.
 *
 * @prop {number} version The version of the report file.
 * @prop {Timestamp} date The timestamp.
 * @prop {string} slot    The slot.
 * @prop {string} rev     Revision of the source.
 * @prop {number} status  Final status of the building process.
 * @prop {string} errstr  Error description, if there is an error.
 * @prop {string} comment Any additional comments from the slot owner.
 *
 * @prop {string} arch    The architecture.
 * @prop {string} subarch The variant of the architecture.
 * @prop {string} cpu     The selected CPU.
 * @prop {string} os      The operating system.
 * @prop {string} cc      The compiler.
 * @prop {string} config  The build-time configure flags.
 *
 * @prop {number} ntests  Number of tests run.
 * @prop {number} npass   Number of tests passed.
 * @prop {number} nfail   Number of failed tests
 * @prop {number} nwarn   Number of compiler warnings.
 *
 * @prop {string} rclass  HTML class of the run
 * @prop {string} rtext   HTML text of the run
 *
 * @constructor
 */
module.exports.Summary = function (h, c, s) {
  var prop
  for (prop in h) {
    if (prop !== 'header') {
      if (h.hasOwnProperty(prop)) this[prop] = h[prop]
    }
  }
  for (prop in c) {
    if (prop !== 'header') {
      if (c.hasOwnProperty(prop)) this[prop] = c[prop]
    }
  }
  for (prop in s) {
    if (prop !== 'header') {
      if (s.hasOwnProperty(prop)) this[prop] = s[prop]
    }
  }

  // Postprocessing
  // Calculate nfail property
  this.nfail = this.ntests - this.npass

  // Calculate rclass and rtext for HTML display
  if (this.npass) {
    this.rclass = this.nfail ? 'warn' : 'pass'
    this.rtext  = this.npass + ' / ' + this.ntests
  } else if (!this.ntests && !this.status) {
    this.rclass = 'pass'
    this.rtext  = 'build only'
  } else {
    this.rclass = 'fail'
    this.rtext  = this.errstr
  }

  // Always make subarch non-empty
  if (!this.subarch) this.subarch = this.arch
}
var Summary = module.exports.Summary

/**
 * This type of callback is used for {@link loadSummary}() that returns an
 * {@link Summary} object.
 *
 * @callback summaryCallback
 * @param {Error}   err The error occurred in the function if any.
 * @param {Summary} rep The resulting {@link Summary} object. (rep = report)
 */

/**
 * Load an old style summary file.
 *
 * Please always call loadSummary() instead of calling this directly.
 *
 * @param slot     {string}         The slot.
 * @param date     {Timestamp}      The timestamp.
 * @param callback {summaryCallback} Callback receiving the Summary object.
 * @private
 */
function loadSummaryFile (slot, date, callback) {
  var header = null, config = null, stats = null
  var repdir = path.join(fateConfig.dir, slot, date)

  var summary = fs.createReadStream(
    path.join(repdir, 'summary')
  ).on('error', function (err) {
    err.HTMLMessage = 'Slot "' + slot + '" does not exist.'
    err.status = 404
    return callback(err)
  })

  var err = null

  var lr = new readline.createInterface({
    input: summary
  , terminal: false
  })

  lr.on('line', function handleLine (line) {
    function checkLine (obj, name) {
      if (!obj) {
        var msg = "Could not parse " + name + " correctly:\n" + line
        if (err) {
          err.message += '\n'
          err.message += msg
          // Don't append stack trace as the stack trace
          // is always going to be the same
        } else {
          err = new Error(msg)
          err.status = 500
        }
      }
    }
    switch (line.split(':')[0]) {
    case 'fate':
      if (!header) {
        header = splitHeader(line)
        checkLine(header, 'header')
      }
      break
    case 'config':
      if (!config) {
        config = splitConfig(line)
        checkLine(config, 'config')
      }
      break
    case 'stats':
      if (!stats) {
        stats = splitStats(line)
        checkLine(stats, 'stats')
      }
      break
    // FIXME: should we error out on unrecognized lines too?
    }
  }).on('close', function close () {
    callback(err, new Summary(header, config, stats))
  })
}

/**
 * Load the summary of an entry.
 *
 * This automatically manages whether to read old-style summary file or
 * new summary.json file.
 *
 * @param slot     {string}         The slot.
 * @param date     {Timestamp}      The timestamp.
 * @param callback {summaryCallback} Callback receiving the {@link Summary}
 *                                  object.
 */
module.exports.loadSummary = loadSummaryFile
var loadSummary = module.exports.loadSummary

/**
 * This type of callback is used for functions that return an array of
 * {@link Record} object(s).
 *
 * @callback recCallback
 *
 * @param {Error}          err  The error occurred in the function, if any.
 * @param {Array.<Record>} recs The resulting array of {@link Record} object.
 */
/**
 * Gets and decompresses an xz report file into a stream.
 *
 * @todo Fix xz error check
 *
 * @param slot     {string}         The slot.
 * @param date     {number}         The timestamp.
 * @param callback {streamCallback} Callback receiving the Readable stream.
 *
 * @private
 */
function unxzReport (slot, date, callback) {
  var repFile = path.join(slot, date, 'report.xz')
  var repPath = path.join(fateConfig.dir, repFile)
  if (fs.existsSync(repPath)) {
    var fileStream = fs.createReadStream(repPath)
                       .on('error', function noReport (err) {
        err.status = 404
        err.HTMLMessage = 'Report "' + repFile + '" not found.'
        return callback(err)
    })

    // FIXME: this error checking doesn't work, because when the
    // err is returned, callback is already called once without err
    // and headers are sent. We can't error out after headers are sent.
    // This means that when trying to decompress the damaged xz file,
    // it automatically falls back to a 500 default error handler that
    // shows an empty page, and logs a bunch of dirty errors on console.
    // But in any case, an error here doesn't happen very often, so
    // no need to worry about it.
    callback(null, fileStream.pipe(xz.d().on('error', function xzErr (err) {
      err.status = 500
      err.HTMLMessage = 'Report "' + repFile + '" damaged.'
      return callback(err)
    })))
  } else {
    var err = new Error(repPath + ' not found.')
    err.status = 404
    err.HTMLMessage = 'Report "' + repFile + '" not found.'
    return callback(err)
  }
}

var loadReportStream = function (stream, errdiff, callback) {
  var recs = []

  var lr = new readline.createInterface({
    input: stream
  , terminal: false
  })

  lr.on('line', function handleLine (line) {
    var rec = splitRec(line, errdiff)
    // Don't care to check if the line is indeed a test record.
    // Depend on splitRec()'s judgment.
    if (rec && rec.name != 'fate' && rec.name != 'config') {
      recs[recs.length] = rec
    }
  }).on('close', function close () {
    // XXX: should we consider no records as an error?
    callback(null, recs.sort(sort.by('name')))
  })
}

/**
 * Load the test report of an entry. It loads the xz-compressed report.xz and
 * splits it into {@link Record}s, then calls the callback with the completed
 * data.
 *
 * @param slot     {string}          The slot.
 * @param date     {number}          The timestamp.
 * @param callback {recCallback}     Callback receiving the array of
 *                                   {@link Record} objects.
 */
module.exports.loadReport = function (slot, date, errdiff, callback) {
  var repFile = path.join(slot, date, 'report.xz')
  var repPath = path.join(fateConfig.dir, repFile)

  unxzReport(slot, date, function unxzCb (err, stream) {
    if (err) return callback(err)
    loadReportStream(stream, errdiff, callback)
  })
}

/**
 * Get the slot owner name.
 * The owner of a slot is stored in <fatedir>/<slot>/owner.
 *
 * @param slot {string} The slot.
 * @return     {string} The owner of the slot.
 */
module.exports.getSlotOwner = function (slot) {
  var data = null

  try {
    data = fs.readFileSync(path.join(fateConfig.dir, slot, 'owner')
                         , 'utf8')
  } catch (err) {
    // ignore error
    // at worst the page will display "owner: null" anyway
    // no need to handle it
  }

  return data
}
var getSlotOwner = module.exports.getSlotOwner

module.exports.loadLastPass = function (slot, callback) {
  var debug = require('debug')('f:parse:loadLastPass')

  var repdir = path.join(fateConfig.dir, slot)

  var lastPass = fs.createReadStream(
    path.join(repdir, 'lastpass')
  ).on('error', function noSlotLastpass (err) {
    err.HTMLMessage = 'Slot "' + slot + '" does not exist.'
    err.status = 404
    return callback(err)
  })

  var recs = []

  var lr = new readline.createInterface({
    input: lastPass
  , terminal: false
  })
  lr.on('line', function handleLine (line) {
    var splittedLine = line.split(':')
    if (splittedLine.length !== 3) return
    // Can't use splitLine() here because we are using the first item
    // as the property name of the inner property, not as a property in
    // the inner object.
    recs[splittedLine[0]] = {
      date: Number(splittedLine[1])
    , rev:  splittedLine[2]
    }
  }).on('close', function close () {
    callback(null, recs)
  })
}
